# SPDX-FileCopyrightText: Copyright (c) 2024-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

name: Docker Build and Test

on:
  push:
#     branches:
#       - main
#       - "pull-request/[0-9]+"
#       - release/*.*.*
#   workflow_dispatch:
#     inputs:
#       run_deploy_operator:
#         description: 'Run deploy operator and deployment tests'
#         required: false
#         type: boolean
#         default: false

# concurrency:
#     # The group name is a ternary operation. If the ref_name is 'main',
#     # then the group name uses the run_id to ensure a unique group for
#     # 'main' pushes. Otherwise, the group name is the ref_name, so that
#     # workflows on the same PR/branch have the same group name for cancelling.
#     group: docker-build-test-${{ github.ref_name == 'main' && github.run_id || github.ref_name }}
#     cancel-in-progress: ${{ github.ref != 'refs/heads/main' }}

env:
  BUILDER_NAME: dynamo-builder # here for simplifying while developing
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}

jobs:
  # ============================================================================
  # SETUP & DETECTION JOBS
  # ============================================================================
  changed-files:
    runs-on: ubuntu-latest
    environment: ${{ github.event_name == 'workflow_dispatch' && 'protected-deploy' || '' }}
    outputs:
      core: ${{ steps.filter.outputs.core }}
      operator: ${{ steps.filter.outputs.operator }}
      deploy: ${{ steps.filter.outputs.deploy }}
      vllm: ${{ steps.filter.outputs.vllm }}
      sglang: ${{ steps.filter.outputs.sglang }}
      trtllm: ${{ steps.filter.outputs.trtllm }}
    steps:
      - name: Checkout code
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Check for changes
        uses: dorny/paths-filter@de90cc6fb38fc0963ad72b210f1f284cd68cea36  # v3.0.2
        id: filter
        with:
          filters: .github/filters.yaml

  detect-buildkit-workers:
    name: Detect Buildkit Workers
    runs-on: builder-cpu-amd-runner
    steps:
    - name: Checkout code
      uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0


    - name: Route Buildkit Workers
      id: route-buildkit-workers
      shell: bash
      run: |
        .github/scripts/route_buildkit.sh --amd
        # .github/scripts/route_buildkit.sh --arm
    outputs:
      vllm_amd64: ${{ steps.route-buildkit-workers.outputs.vllm_amd64 }}
      vllm_arm64: ${{ steps.route-buildkit-workers.outputs.vllm_arm64 }}
      trtllm_amd64: ${{ steps.route-buildkit-workers.outputs.trtllm_amd64 }}
      trtllm_arm64: ${{ steps.route-buildkit-workers.outputs.trtllm_arm64 }}
      sglang_amd64: ${{ steps.route-buildkit-workers.outputs.sglang_amd64 }}
      sglang_arm64: ${{ steps.route-buildkit-workers.outputs.sglang_arm64 }}
      general_amd64: ${{ steps.route-buildkit-workers.outputs.general_amd64 }}
      general_arm64: ${{ steps.route-buildkit-workers.outputs.general_arm64 }}

  # # ============================================================================
  # # BUILD JOBS
  # # Build container images for all frameworks (vllm, sglang, trtllm, operator)
  # # Each framework builds for both amd64 and arm64 architectures
  # # ============================================================================

  operator:
    needs: detect-buildkit-workers
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: amd64 }
          # - { arch: arm64  }
    name: operator (${{ matrix.platform.arch }})
    runs-on: builder-cpu-amd-runner
    steps:
      - name: define buildkit builders
        shell: bash
        run: |
          ADDRS="${{ needs.detect-buildkit-workers.outputs[format('general_{0}', matrix.platform.arch)] }}"
          IFS=',' read -ra ADDR_LIST <<< "$ADDRS"
          FIRST=true
          for addr in "${ADDR_LIST[@]}"; do
            if $FIRST; then
              docker buildx create --use --name ${{ env.BUILDER_NAME }} --driver remote "$addr"
              FIRST=false
            else
              docker buildx create --append --name ${{ env.BUILDER_NAME }} --driver remote "$addr"
            fi
          done
          docker buildx inspect --bootstrap
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Docker Login
        uses: ./.github/actions/docker-login
        with:
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
      - name: Linter
        shell: bash
        working-directory: ./deploy/operator
        env:
          ECR_HOSTNAME: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com
        run: |
          docker buildx build --platform linux/${{ matrix.platform.arch }} --target linter --progress=plain --build-arg DOCKER_PROXY=${ECR_HOSTNAME}/dockerhub/ .
      - name: Tester
        shell: bash
        working-directory: ./deploy/operator
        env:
          ECR_HOSTNAME: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com
        run: |
          docker buildx build --platform linux/${{ matrix.platform.arch }}  --target tester --progress=plain --build-arg DOCKER_PROXY=${ECR_HOSTNAME}/dockerhub/ .
      - name: Set up Go
        uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version: '1.24'
      - name: Check for uncommitted changes
        shell: bash
        working-directory: ./deploy/operator
        env:
          ECR_HOSTNAME: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com
        run: |
          sudo apt-get update && sudo apt-get install -y make
          make check
      - name: Build Container
        id: build-image
        shell: bash
        working-directory: ./deploy/operator
        env:
          ECR_HOSTNAME: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com
        run: |
          docker buildx build --push \
              --platform linux/${{ matrix.platform.arch }} \
              --build-arg DOCKER_PROXY=${ECR_HOSTNAME}/dockerhub/ \
              -f Dockerfile \
              -t  ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/ai-dynamo/dynamo:${{ github.sha }}-dynamo-operator-${{ matrix.platform.arch }} .


  build-vllm:
    needs: detect-buildkit-workers
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: amd64 }
          # - { arch: arm64 }
        framework:
          - { name: vllm, arm_base_image_tag: '25.06-cuda12.9-devel-ubuntu24.04', arm_runtime_image_tag: '12.9.0-runtime-ubuntu24.04', arm_cuda_version: '12.9', arm_torch_backend: 'cu129' }
    name: build ${{ matrix.framework.name }}-${{ matrix.platform.arch }}
    runs-on: builder-cpu-amd-runner
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Build with Remote Buildkit
        id: build-image
        uses: ./.github/actions/build-with-buildkit
        with:
          # no_cache: 'true'
          builder_name: ${{ env.BUILDER_NAME }}
          buildkit_worker_addresses: ${{ needs.detect-buildkit-workers.outputs[format('{0}_{1}', matrix.framework.name, matrix.platform.arch)] }}
          image_tag: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/ai-dynamo/dynamo:${{ github.sha }}-${{ matrix.framework.name }}-${{ matrix.platform.arch }}
          framework: ${{ matrix.framework.name }}
          target: runtime
          platform: 'linux/${{ matrix.platform.arch }}'
          base_image_tag: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_base_image_tag || '' }}
          runtime_image_tag: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_runtime_image_tag || '' }}
          cuda_version: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_cuda_version || '' }}
          torch_backend: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_torch_backend || '' }}
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
          ci_token: ${{ secrets.CI_TOKEN }}
          sccache_s3_bucket: ${{ secrets.SCCACHE_S3_BUCKET }}
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}


  build-sglang:
    needs: detect-buildkit-workers
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: amd64 }
          # - { arch: arm64 }
        framework:
          - { name: sglang, arm_base_image_tag: '', arm_runtime_image_tag: '', arm_cuda_version: '', arm_torch_backend: '' }
    name: build ${{ matrix.framework.name }}-${{ matrix.platform.arch }}
    runs-on: builder-cpu-amd-runner
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Build with Remote Buildkit
        id: build-image
        uses: ./.github/actions/build-with-buildkit
        with:
          # no_cache: 'true'
          builder_name: ${{ env.BUILDER_NAME }}
          buildkit_worker_addresses: ${{ needs.detect-buildkit-workers.outputs[format('{0}_{1}', matrix.framework.name, matrix.platform.arch)] }}
          image_tag: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/ai-dynamo/dynamo:${{ github.sha }}-${{ matrix.framework.name }}-${{ matrix.platform.arch }}
          framework: ${{ matrix.framework.name }}
          target: runtime
          platform: 'linux/${{ matrix.platform.arch }}'
          base_image_tag: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_base_image_tag || '' }}
          runtime_image_tag: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_runtime_image_tag || '' }}
          cuda_version: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_cuda_version || '' }}
          torch_backend: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_torch_backend || '' }}
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
          ci_token: ${{ secrets.CI_TOKEN }}
          sccache_s3_bucket: ${{ secrets.SCCACHE_S3_BUCKET }}
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  build-trtllm:
    needs: detect-buildkit-workers
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: amd64 }
          # - { arch: arm64 }
        framework:
          - { name: trtllm, arm_base_image_tag: '', arm_runtime_image_tag: '', arm_cuda_version: '', arm_torch_backend: '' }
    name: build ${{ matrix.framework.name }}-${{ matrix.platform.arch }}
    runs-on: builder-cpu-amd-runner
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Build with Remote Buildkit
        id: build-image
        uses: ./.github/actions/build-with-buildkit
        with:
          # no_cache: 'true'
          builder_name: ${{ env.BUILDER_NAME }}
          buildkit_worker_addresses: ${{ needs.detect-buildkit-workers.outputs[format('{0}_{1}', matrix.framework.name, matrix.platform.arch)] }}
          image_tag: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/ai-dynamo/dynamo:${{ github.sha }}-${{ matrix.framework.name }}-${{ matrix.platform.arch }}
          framework: ${{ matrix.framework.name }}
          target: runtime
          platform: 'linux/${{ matrix.platform.arch }}'
          base_image_tag: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_base_image_tag || '' }}
          runtime_image_tag: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_runtime_image_tag || '' }}
          cuda_version: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_cuda_version || '' }}
          torch_backend: ${{ matrix.platform.arch == 'arm64' && matrix.framework.arm_torch_backend || '' }}
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
          ci_token: ${{ secrets.CI_TOKEN }}
          sccache_s3_bucket: ${{ secrets.SCCACHE_S3_BUCKET }}
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  # ============================================================================
  # TEST JOBS
  # Run pytest suites against built images (amd64 only, requires GPU runners)
  # ============================================================================
  pytests-vllm:
    needs: [build-vllm, operator]
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: amd64, runner: gpu-l40-amd64 }
        framework:
          - { name: vllm }
    name: run pytests for ${{ matrix.framework.name }}-${{ matrix.platform.arch }}
    runs-on: ${{ matrix.platform.runner }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
        # with:
        #   ref: main
      - name: Docker Login
        uses: ./.github/actions/docker-login
        with:
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
      # - name: Run tests
      #   uses: ./.github/actions/pytest
      #   with:
      #     image_tag: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/ai-dynamo/dynamo:${{ github.sha }}-${{ matrix.framework.name }}-${{ matrix.platform.arch }}
      #     pytest_marks: "pre_merge and ${{ matrix.framework.name }} and (gpu_0 or gpu_1)"
      #     framework: "${{ matrix.framework.name }}"
      #     test_type: "pre_merge"
      #     platform_arch: ${{ matrix.platform.arch }}

  pytests-sglang:
    needs: [build-sglang, operator]
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: amd64, runner: gpu-l40-amd64 }
        framework:
          - { name: sglang }
    name: run pytests for ${{ matrix.framework.name }}-${{ matrix.platform.arch }}
    runs-on: ${{ matrix.platform.runner }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
        # with:
        #   ref: main
      - name: Docker Login
        uses: ./.github/actions/docker-login
        with:
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
      # - name: Run tests
      #   uses: ./.github/actions/pytest
      #   with:
      #     image_tag: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/ai-dynamo/dynamo:${{ github.sha }}-${{ matrix.framework.name }}-${{ matrix.platform.arch }}
      #     pytest_marks: "pre_merge and ${{ matrix.framework.name }} and (gpu_0 or gpu_1)"
      #     framework: "${{ matrix.framework.name }}"
      #     test_type: "pre_merge"
      #     platform_arch: ${{ matrix.platform.arch }}

  pytests-trtllm:
    needs: [build-trtllm, operator]
    strategy:
      fail-fast: false
      matrix:
        platform:
          - { arch: amd64, runner: gpu-l40-amd64 }
        framework:
          - { name: trtllm }
    name: run pytests for ${{ matrix.framework.name }}-${{ matrix.platform.arch }}
    runs-on: ${{ matrix.platform.runner }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
        # with:
        #   ref: main
      - name: Docker Login
        uses: ./.github/actions/docker-login
        with:
          ngc_ci_access_token: ${{ secrets.NGC_CI_ACCESS_TOKEN }}
          aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
      # - name: Run tests
      #   uses: ./.github/actions/pytest
      #   with:
      #     image_tag: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com/ai-dynamo/dynamo:${{ github.sha }}-${{ matrix.framework.name }}-${{ matrix.platform.arch }}
      #     pytest_marks: "pre_merge and ${{ matrix.framework.name }} and (gpu_0 or gpu_1)"
      #     framework: "${{ matrix.framework.name }}"
      #     test_type: "pre_merge"
      #     platform_arch: ${{ matrix.platform.arch }}


  # ============================================================================
  # IMAGE DISTRIBUTION JOBS
  # Copy built images from AWS ECR to Azure ACR after tests pass
  # ============================================================================
  copy-images-to-acr:
    needs: [pytests-vllm, pytests-sglang, pytests-trtllm, operator]
    strategy:
      fail-fast: true
      matrix:
        platform:
          - { arch: amd64 }
          # - { arch: arm64 }
        framework:
          - { name: vllm }
          - { name: sglang }
          - { name: trtllm }
          - { name: dynamo-operator }
    name: copy ${{ matrix.framework.name }}-${{ matrix.platform.arch }}
    runs-on: builder-cpu-amd-runner
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
      - name: Calculate target tag
        id: calculate-target-tag
        shell: bash
        run: |
          TARGET_TAG="${{ github.sha }}-${{ matrix.framework.name }}-${{ matrix.platform.arch }}"
          echo "target_tag=${TARGET_TAG}" >> $GITHUB_OUTPUT
          # Set framework+arch specific output for static output mapping
          echo "target_tag_${{ matrix.framework.name }}_${{ matrix.platform.arch }}=${TARGET_TAG}" >> $GITHUB_OUTPUT
      - name: Copy image to target registry
        uses: ./.github/actions/skopeo-copy
        with:
          source_registry: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_DEFAULT_REGION }}.amazonaws.com
          source_image: ai-dynamo/dynamo
          source_tag: ${{ github.sha }}-${{ matrix.framework.name }}-${{ matrix.platform.arch }}
          target_registry: ${{ secrets.AZURE_ACR_HOSTNAME }}
          target_image: ai-dynamo/dynamo
          target_tag: ${{ steps.calculate-target-tag.outputs.target_tag }}
          # Source ECR credentials
          source_aws_default_region: ${{ secrets.AWS_DEFAULT_REGION }}
          source_aws_account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          # Target ACR credentials
          target_azure_acr_hostname: ${{ secrets.AZURE_ACR_HOSTNAME }}
          target_azure_acr_user: ${{ secrets.AZURE_ACR_USER }}
          target_azure_acr_password: ${{ secrets.AZURE_ACR_PASSWORD }}
    outputs:
      target_tag_vllm_amd64: ${{ steps.calculate-target-tag.outputs.target_tag_vllm_amd64 }}
      target_tag_vllm_arm64: ${{ steps.calculate-target-tag.outputs.target_tag_vllm_arm64 }}
      target_tag_sglang_amd64: ${{ steps.calculate-target-tag.outputs.target_tag_sglang_amd64 }}
      target_tag_sglang_arm64: ${{ steps.calculate-target-tag.outputs.target_tag_sglang_arm64 }}
      target_tag_trtllm_amd64: ${{ steps.calculate-target-tag.outputs.target_tag_trtllm_amd64 }}
      target_tag_trtllm_arm64: ${{ steps.calculate-target-tag.outputs.target_tag_trtllm_arm64 }}
      target_tag_dynamo_operator_amd64: ${{ steps.calculate-target-tag.outputs.target_tag_dynamo-operator_amd64 }}
      target_tag_dynamo_operator_arm64: ${{ steps.calculate-target-tag.outputs.target_tag_dynamo-operator_arm64 }}


  # ============================================================================
  # DEPLOYMENT JOBS
  # Deploy operator and run end-to-end tests on Kubernetes cluster
  # ============================================================================
  deploy-operator:
    runs-on: cpu-amd-m5-2xlarge
    needs: [copy-images-to-acr]
    env:
      DYNAMO_INGRESS_SUFFIX: dev.aire.nvidia.com
    outputs:
      NAMESPACE: ${{ steps.deploy-operator-step.outputs.namespace }}
    steps:
    - name: Output Node Name
      shell: bash
      run: |
        echo ${K8S_NODE_NAME}
    - uses: actions/checkout@v4
    - name: Deploy Operator
      id: deploy-operator-step
      env:
        BRANCH: ${{ github.ref_name }}
      run: |
        set -x

        # Set namespace
        # Invalid patterns: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/
        BRANCH_SANITIZED="${BRANCH//\//-}"
        BRANCH_SANITIZED="${BRANCH_SANITIZED/pull-request/pr}"
        BRANCH_SANITIZED="${BRANCH_SANITIZED//./-}"
        NAMESPACE="gh-id-${{ github.run_id }}-${BRANCH_SANITIZED}-dt"
        echo "namespace=${NAMESPACE}" >> "$GITHUB_OUTPUT"

        # Setup kubeconfig
        echo "${{ secrets.AZURE_AKS_CI_KUBECONFIG_B64 }}" | base64 -d > .kubeconfig
        chmod 600 .kubeconfig
        export KUBECONFIG=$(pwd)/.kubeconfig
        kubectl config set-context --current --namespace=$NAMESPACE --kubeconfig "${KUBECONFIG}"
        kubectl config current-context

        # Create a namespace for this job
        echo "Creating an ephemeral namespace..."
        kubectl create namespace $NAMESPACE
        echo "Attaching the labels for secrets and cleanup"
        kubectl label namespaces ${NAMESPACE} nscleanup/enabled=true nscleanup/ttl=7200 gitlab-imagepull=enabled ngc-api=enabled nvcr-imagepull=enabled --overwrite=true

        # Set the namespace as default
        kubectl config set-context --current --namespace=$NAMESPACE

        # Check if Istio is installed
        kubectl get pods -n istio-system
        # Check if default storage class exists
        kubectl get storageclass

        # Install Helm chart
        export VIRTUAL_ENV=/opt/dynamo/venv
        export KUBE_NS=$NAMESPACE
        export ISTIO_ENABLED=true
        export ISTIO_GATEWAY=istio-system/ingress-alb
        export VIRTUAL_SERVICE_SUPPORTS_HTTPS=true

        # Install dynamo env secrets
        kubectl create secret generic hf-token-secret --from-literal=HF_TOKEN=${{ secrets.HF_TOKEN }} -n $KUBE_NS || true
        # Install helm dependencies
        helm repo add bitnami https://charts.bitnami.com/bitnami
        cd deploy/helm/charts/platform/
        helm dep build .
        # Install platform with namespace restriction for single profile testing
        helm upgrade --install dynamo-platform . --namespace ${NAMESPACE} \
          --set dynamo-operator.namespaceRestriction.enabled=true \
          --set dynamo-operator.namespaceRestriction.allowedNamespaces[0]=${NAMESPACE} \
          --set dynamo-operator.controllerManager.manager.image.repository=${{ secrets.AZURE_ACR_HOSTNAME }}/ai-dynamo/dynamo \
          --set dynamo-operator.controllerManager.manager.image.tag=${{ needs.copy-images-to-acr.outputs.target_tag_dynamo_operator_amd64 }} 
        # Wait for all deployments to be ready
        timeout 300s kubectl rollout status deployment -n $NAMESPACE --watch

  # ============================================================================
  # 
  # End-to-end tests for each framework with various deployment profiles
  # ============================================================================
  deploy-test-vllm:
    runs-on: cpu-amd-m5-2xlarge
    # if: ( github.ref_name == 'main' || github.event.inputs.run_deploy_operator )
    needs: [deploy-operator, copy-images-to-acr]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        profile:
          - agg
          - agg_router
          - disagg
          - disagg_router
    name: deploy-test-vllm (${{ matrix.profile }})
    env:
      FRAMEWORK: vllm
    steps:
      - name: Output Node Name
        run: echo ${K8S_NODE_NAME}
      - uses: actions/checkout@v4
      - name: Run Dynamo Deploy Test
        id: deploy-test
        uses: ./.github/actions/dynamo-deploy-test
        with:
          kubeconfig_base64: ${{ secrets.AZURE_AKS_CI_KUBECONFIG_B64 }}
          namespace: ${{ needs.deploy-operator.outputs.NAMESPACE }}
          deployment_file: deploy/${{ matrix.profile }}.yaml
          framework: vllm
          framework_runtime_image: ${{ secrets.AZURE_ACR_HOSTNAME }}/ai-dynamo/dynamo:${{ needs.copy-images-to-acr.outputs.target_tag_vllm_amd64 }}
          model_name: Qwen/Qwen3-0.6B
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-vllm-${{ matrix.profile }}-${{ github.run_id }}
          path: ${{ steps.deploy-test.outputs.test_log_path }}
          retention-days: 7

  deploy-test-vllm-disagg-router:
    runs-on: cpu-amd-m5-2xlarge
    # if: needs.changed-files.outputs.core == 'true' || needs.changed-files.outputs.vllm == 'true' || needs.changed-files.outputs.deploy == 'true'
    needs: [deploy-operator, copy-images-to-acr]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        profile:
          - disagg_router
    name: deploy-test-vllm (${{ matrix.profile }})
    env:
      FRAMEWORK: vllm
    steps:
      - name: Output Node Name
        run: echo ${K8S_NODE_NAME}
      - uses: actions/checkout@v4
      - name: Run Dynamo Deploy Test
        id: deploy-test
        uses: ./.github/actions/dynamo-deploy-test
        with:
          kubeconfig_base64: ${{ secrets.AZURE_AKS_CI_KUBECONFIG_B64 }}
          namespace: ${{ needs.deploy-operator.outputs.NAMESPACE }}
          deployment_file: deploy/${{ matrix.profile }}.yaml
          framework: vllm
          framework_runtime_image: ${{ secrets.AZURE_ACR_HOSTNAME }}/ai-dynamo/dynamo:${{ needs.copy-images-to-acr.outputs.target_tag_vllm_amd64 }}
          model_name: Qwen/Qwen3-0.6B
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-vllm-${{ matrix.profile }}-${{ github.run_id }}
          path: ${{ steps.deploy-test.outputs.test_log_path }}
          retention-days: 7

  deploy-test-sglang:
    runs-on: cpu-amd-m5-2xlarge
    # if: ( github.ref_name == 'main' || github.event.inputs.run_deploy_operator )
    needs: [deploy-operator, copy-images-to-acr]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        profile:
          - agg
          - agg_router
    name: deploy-test-sglang (${{ matrix.profile }})
    env:
      FRAMEWORK: sglang
    steps:
      - name: Output Node Name
        run: echo ${K8S_NODE_NAME}
      - uses: actions/checkout@v4
      - name: Run Dynamo Deploy Test
        id: deploy-test
        uses: ./.github/actions/dynamo-deploy-test
        with:
          kubeconfig_base64: ${{ secrets.AZURE_AKS_CI_KUBECONFIG_B64 }}
          namespace: ${{ needs.deploy-operator.outputs.NAMESPACE }}
          deployment_file: deploy/${{ matrix.profile }}.yaml
          framework: sglang
          framework_runtime_image: ${{ secrets.AZURE_ACR_HOSTNAME }}/ai-dynamo/dynamo:${{ needs.copy-images-to-acr.outputs.target_tag_sglang_amd64 }}
          model_name: Qwen/Qwen3-0.6B
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-sglang-${{ matrix.profile }}-${{ github.run_id }}
          path: ${{ steps.deploy-test.outputs.test_log_path }}
          retention-days: 7

  deploy-test-trtllm:
    runs-on: cpu-amd-m5-2xlarge
    # if: ( github.ref_name == 'main' || github.event.inputs.run_deploy_operator )
    needs: [deploy-operator, copy-images-to-acr]
    permissions:
      contents: read
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        profile:
          - agg
          - agg_router
          - disagg
          - disagg_router
    name: deploy-test-trtllm (${{ matrix.profile }})
    env:
      FRAMEWORK: trtllm
    steps:
      - name: Output Node Name
        run: echo ${K8S_NODE_NAME}
      - uses: actions/checkout@v4
      - name: Run Dynamo Deploy Test
        id: deploy-test
        uses: ./.github/actions/dynamo-deploy-test
        with:
          kubeconfig_base64: ${{ secrets.AZURE_AKS_CI_KUBECONFIG_B64 }}
          namespace: ${{ needs.deploy-operator.outputs.NAMESPACE }}
          deployment_file: deploy/${{ matrix.profile }}.yaml
          framework: trtllm
          framework_runtime_image: ${{ secrets.AZURE_ACR_HOSTNAME }}/ai-dynamo/dynamo:${{ needs.copy-images-to-acr.outputs.target_tag_trtllm_amd64 }}
          model_name: Qwen/Qwen3-0.6B
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-trtllm-${{ matrix.profile }}-${{ github.run_id }}
          path: ${{ steps.deploy-test.outputs.test_log_path }}
          retention-days: 7

  # ============================================================================
  # CLEANUP JOBS 
  # Clean up ephemeral Kubernetes namespace and resources
  # ============================================================================
  cleanup:
    runs-on: cpu-amd-m5-2xlarge
    if: always()
    needs: [deploy-test-sglang, deploy-test-trtllm, deploy-test-vllm, deploy-test-vllm-disagg-router]
    steps:
    - name: Output Node Name
      shell: bash
      run: |
        echo ${K8S_NODE_NAME}
    - uses: actions/checkout@v4
    - name: Setup Kubeconfig
      env:
        NAMESPACE: ${{ needs.deploy-operator.outputs.NAMESPACE }}
      run: |
        set -x
        # Setup kubeconfig
        echo "${{ secrets.AZURE_AKS_CI_KUBECONFIG_B64 }}" | base64 -d > .kubeconfig
        chmod 600 .kubeconfig
        export KUBECONFIG=$(pwd)/.kubeconfig
        kubectl config set-context --current --namespace=$NAMESPACE --kubeconfig "${KUBECONFIG}"
        kubectl config current-context
    - name: Cleanup
      timeout-minutes: 5
      env:
        NAMESPACE: ${{ needs.deploy-operator.outputs.NAMESPACE }}
      run: |
        set -x
        export KUBECONFIG=$(pwd)/.kubeconfig
        kubectl config set-context --current --namespace=$NAMESPACE

        echo "${{ secrets.AZURE_AKS_CI_KUBECONFIG_B64 }}" | base64 -d > .kubeconfig
        chmod 600 .kubeconfig
        export KUBECONFIG=$(pwd)/.kubeconfig
        kubectl config set-context --current --namespace=$NAMESPACE --kubeconfig "${KUBECONFIG}"

        # For debugging purposes, list all the resources before we uninstall
        kubectl get dynamographdeployments
        kubectl get all

        echo "Deleting all DynamoGraphDeployments in namespace $NAMESPACE..."
        kubectl delete dynamographdeployments --all -n $NAMESPACE || true

        # Uninstall the helm chart
        helm ls
        helm uninstall dynamo-platform --namespace $NAMESPACE || true

        echo "Namespace $NAMESPACE deletion initiated, proceeding with cleanup..."
        kubectl delete namespace $NAMESPACE || true
        echo "Namespace $NAMESPACE completed."
