# SPDX-FileCopyrightText: Copyright (c) 2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# LGTM Bot PR Open - Runs when a PR is opened or updated.
# Features:
#   1. Auto-request reviews from CODEOWNERS teams + individual reviewer assignment
#   2. Post a comment listing required CODEOWNERS teams
#   Plus: Fork CI detection for external contributors
#
# Note: PR size labels are managed by an existing integration.

name: LGTM Bot PR Open

on:
  pull_request_target:
    types: [opened, synchronize, reopened]

permissions:
  pull-requests: write
  contents: read

jobs:
  pr-onboard:
    name: PR Onboarding
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Onboard PR
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          REVIEWERS_YAML: ${{ secrets.LGTM_BOT_REVIEWERS_YAML }}
          REVIEWERS_PER_TEAM: ${{ vars.LGTM_BOT_REVIEWERS_PER_TEAM || '1' }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const headSha = pr.head.sha;
            const isFork = pr.head.repo?.full_name !== `${context.repo.owner}/${context.repo.repo}`;
            const isOpened = ['opened', 'reopened'].includes(context.payload.action);

            console.log(`Processing PR #${prNumber} (${context.payload.action}, fork=${isFork})`);

            // ============================================================
            // CODEOWNERS parsing (shared by Features 3 & 4)
            // ============================================================

            // Fetch CODEOWNERS file from base branch
            let codeownersContent = '';
            try {
              const { data: codeownersFile } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'CODEOWNERS',
                ref: pr.base.ref,
              });
              codeownersContent = Buffer.from(codeownersFile.content, 'base64').toString();
            } catch (e) {
              console.log('Could not fetch CODEOWNERS file:', e.message);
            }

            if (!codeownersContent) {
              console.log('No CODEOWNERS file found, skipping review request and comment');
              return;
            }

            // Parse CODEOWNERS into rules
            const rules = [];
            for (const line of codeownersContent.split('\n')) {
              const trimmed = line.trim();
              if (!trimmed || trimmed.startsWith('#')) continue;
              const parts = trimmed.split(/\s+/);
              if (parts.length < 2) continue;
              const pattern = parts[0];
              const teams = parts.slice(1).filter(p => p.startsWith('@'));
              if (teams.length) rules.push({ pattern, teams });
            }

            // Simple glob matcher for CODEOWNERS patterns
            function globMatch(str, pattern) {
              const re = pattern
                .replace(/[.+^${}()|[\]\\]/g, '\\$&')
                .replace(/\*\*/g, '{{GLOBSTAR}}')
                .replace(/\*/g, '[^/]*')
                .replace(/\?/g, '[^/]')
                .replace(/\{\{GLOBSTAR\}\}/g, '.*');
              return new RegExp(`^${re}$`).test(str);
            }

            // Match a filepath against CODEOWNERS rules (last match wins)
            // Follows GitHub CODEOWNERS pattern matching rules:
            // - Anchored patterns (start with /) match from repo root
            // - Unanchored patterns without / match filename at any depth
            // - Unanchored patterns with / match full path and all suffixes
            // - Directory patterns (end with /) match any file under that directory
            function matchFile(filepath) {
              let matched = [];
              for (const rule of rules) {
                const p = rule.pattern;
                const anchored = p.startsWith('/');
                const clean = anchored ? p.slice(1) : p;

                if (clean.endsWith('/')) {
                  const dir = clean;
                  if (anchored) {
                    if (filepath.startsWith(dir)) matched = rule.teams;
                  } else {
                    // Unanchored directory: match anywhere in path
                    if (filepath.startsWith(dir) || ('/' + filepath).includes('/' + dir)) {
                      matched = rule.teams;
                    }
                  }
                } else if (anchored) {
                  // Anchored file/glob pattern â€” match from repo root
                  if (globMatch(filepath, clean)) matched = rule.teams;
                } else {
                  // Unanchored pattern
                  if (clean.includes('/')) {
                    // Pattern has path separator: match full path and all suffixes
                    if (globMatch(filepath, clean)) {
                      matched = rule.teams;
                    } else {
                      const parts = filepath.split('/');
                      for (let i = 0; i < parts.length; i++) {
                        const suffix = parts.slice(i).join('/');
                        if (globMatch(suffix, clean)) {
                          matched = rule.teams;
                          break;
                        }
                      }
                    }
                  } else {
                    // Simple pattern without /: match filename at any depth
                    const filename = filepath.split('/').pop();
                    if (globMatch(filename, p)) matched = rule.teams;
                  }
                }
              }
              return matched;
            }

            // Fetch changed files
            let changedFiles = [];
            let page = 1;
            while (true) {
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100,
                page,
              });
              changedFiles = changedFiles.concat(files.map(f => f.filename));
              if (files.length < 100) break;
              page++;
            }

            // Build team -> files map
            const teamFiles = {};
            for (const filepath of changedFiles) {
              const teams = matchFile(filepath);
              for (const team of teams) {
                if (!teamFiles[team]) teamFiles[team] = [];
                teamFiles[team].push(filepath);
              }
            }

            const requiredTeams = Object.keys(teamFiles);
            console.log(`Required CODEOWNERS teams: ${requiredTeams.join(', ') || 'none'}`);

            // ============================================================
            // Feature 3: Auto-request reviews (on open only)
            //   - Request team reviews from CODEOWNERS teams
            //   - Assign individual reviewers via team member resolution
            //     and/or YAML roster from LGTM_BOT_REVIEWERS_YAML secret
            // ============================================================

            if (isOpened && requiredTeams.length > 0) {
              // Helper: pick N random items from an array
              function pickRandom(arr, n) {
                const shuffled = [...arr].sort(() => Math.random() - 0.5);
                return shuffled.slice(0, n);
              }

              const prAuthor = pr.user.login;
              const reviewersPerTeam = parseInt(process.env.REVIEWERS_PER_TEAM || '1', 10);

              // Extract team slugs from @org/team format
              const teamSlugs = requiredTeams
                .map(t => {
                  const match = t.match(/@([^/]+)\/(.+)/);
                  return match ? { org: match[1], slug: match[2], full: `${match[1]}/${match[2]}` } : null;
                })
                .filter(Boolean);

              // Request team-level reviews
              const slugNames = teamSlugs.map(t => t.slug);
              if (slugNames.length > 0) {
                try {
                  await github.rest.pulls.requestReviewers({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    team_reviewers: slugNames,
                  });
                  console.log(`Requested team reviews from: ${slugNames.join(', ')}`);
                } catch (e) {
                  console.log(`Could not request some team reviews: ${e.message}`);
                }
              }

              // --- Individual reviewer assignment ---
              const individualReviewers = new Set();

              // Option 1: Resolve CODEOWNERS teams to individual members
              for (const team of teamSlugs) {
                try {
                  const { data: members } = await github.rest.teams.listMembersInOrg({
                    org: team.org,
                    team_slug: team.slug,
                    per_page: 100,
                  });
                  const eligible = members.map(m => m.login).filter(l => l !== prAuthor);
                  const picks = pickRandom(eligible, reviewersPerTeam);
                  for (const p of picks) individualReviewers.add(p);
                  console.log(`Team ${team.full}: ${eligible.length} eligible â†’ picked ${picks.join(', ') || 'none'}`);
                } catch (e) {
                  console.log(`Could not resolve team ${team.full}: ${e.message}`);
                }
              }

              // Option 2: Roster from LGTM_BOT_REVIEWERS_YAML secret
              // Expected YAML format:
              //   default: [user1, user2]
              //   rust: [user3, user4]
              //   python: [user5]
              const rosterYaml = process.env.REVIEWERS_YAML || '';
              if (rosterYaml.trim()) {
                try {
                  // Lightweight YAML-subset parser for key: [val, val] format
                  const roster = {};
                  for (const line of rosterYaml.split('\n')) {
                    const trimmed = line.trim();
                    if (!trimmed || trimmed.startsWith('#')) continue;
                    const colonIdx = trimmed.indexOf(':');
                    if (colonIdx === -1) continue;
                    const key = trimmed.slice(0, colonIdx).trim();
                    let valStr = trimmed.slice(colonIdx + 1).trim().replace(/^\[|\]$/g, '');
                    const vals = valStr.split(',').map(v => v.trim()).filter(Boolean);
                    if (vals.length) roster[key] = vals;
                  }

                  const matchedKeys = new Set();
                  for (const filepath of changedFiles) {
                    for (const key of Object.keys(roster)) {
                      if (key === 'default') continue;
                      if (filepath.includes(key) || filepath.endsWith(`.${key}`)) {
                        matchedKeys.add(key);
                      }
                    }
                  }
                  if (roster['default']) matchedKeys.add('default');

                  for (const key of matchedKeys) {
                    const candidates = (roster[key] || []).filter(u => u !== prAuthor);
                    const picks = pickRandom(candidates, reviewersPerTeam);
                    for (const p of picks) individualReviewers.add(p);
                    console.log(`Roster "${key}": ${candidates.length} eligible â†’ picked ${picks.join(', ') || 'none'}`);
                  }
                } catch (e) {
                  console.log(`Roster assignment error: ${e.message}`);
                }
              }

              // Request individual reviews
              const reviewersList = [...individualReviewers];
              if (reviewersList.length > 0) {
                try {
                  await github.rest.pulls.requestReviewers({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    reviewers: reviewersList,
                  });
                  console.log(`Requested individual reviews from: ${reviewersList.join(', ')}`);
                } catch (e) {
                  console.log(`Could not request some individual reviews: ${e.message}`);
                }
              }
            }

            // ============================================================
            // Feature 4: CODEOWNERS visibility comment
            // ============================================================

            const CODEOWNERS_MARKER = '<!-- lgtm-bot-codeowners -->';

            // Determine reason for each team
            function teamReason(team) {
              if (team.includes('rust')) return 'Rust files changed';
              if (team.includes('python')) return 'Python files changed';
              if (team.includes('Devops')) return 'CI/infra files changed';
              if (team.includes('deploy')) return 'Deploy files changed';
              return 'Files changed';
            }

            let commentLines = [
              CODEOWNERS_MARKER,
              '## ðŸ¤– LGTM Bot â€” Required Reviewers',
              '',
              'Based on the files changed in this PR, the following teams need to review:',
              '',
              '| Team | Reason | Files |',
              '|------|--------|-------|',
            ];

            for (const [team, files] of Object.entries(teamFiles)) {
              const fileList = files.slice(0, 3).map(f => `\`${f}\``).join(', ');
              const more = files.length > 3 ? ` (+${files.length - 3} more)` : '';
              commentLines.push(`| ${team} | ${teamReason(team)} | ${fileList}${more} |`);
            }

            commentLines.push('');
            if (isOpened) {
              commentLines.push('Reviews have been automatically requested.');
            }

            // CI trigger guidance
            commentLines.push('');
            commentLines.push('> **Triggering CI**:');
            commentLines.push('> - **First-time contributors**: A maintainer must comment');
            commentLines.push(`>   \`/ok to test ${headSha.slice(0, 7)}\` to trigger CI. This must be re-issued after every new push.`);
            commentLines.push('> - **L1 contributors**: A maintainer must run `/ok to test` once; subsequent pushes trigger CI automatically.');
            commentLines.push('> - **L2+ external contributors and org members**: CI triggers automatically with GPG-signed commits.');

            commentLines.push('');
            commentLines.push('---');
            commentLines.push('_This comment updates automatically when new commits are pushed._');

            const commentBody = commentLines.join('\n');

            // Find existing comment or create new one (search newest first)
            let existingComment = null;
            let commentPage = 1;
            while (!existingComment) {
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                per_page: 100,
                page: commentPage,
                direction: 'desc',
              });
              if (comments.length === 0) break;
              existingComment = comments.find(c => c.body && c.body.includes(CODEOWNERS_MARKER));
              commentPage++;
            }
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody,
              });
              console.log('Updated CODEOWNERS comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody,
              });
              console.log('Created CODEOWNERS comment');
            }
