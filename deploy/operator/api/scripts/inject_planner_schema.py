#!/usr/bin/env python3
# SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Post-process the DGDR CRD YAML to inject the PlannerConfig JSON schema.

Run after controller-gen produces the CRD YAML. Replaces the generic
``type: object`` schema for ``spec.features.planner`` with the
full validated OpenAPI v3 schema derived from
``api/schemas/planner_config_json_schema.json`` (generated by
``make generate-planner-schema``).

Usage
-----
    python deploy/operator/api/scripts/inject_planner_schema.py

Or via the Makefile target::

    make inject-planner-schema
"""

from __future__ import annotations

import copy
import json
import sys
from pathlib import Path

import yaml

# Both paths are within deploy/operator/, so resolve relative to this script.
# This works in both the full repo checkout and the operator-only Docker build context.
_OPERATOR_DIR = Path(__file__).resolve().parents[2]

_CRD_FILE = (
    _OPERATOR_DIR
    / "config"
    / "crd"
    / "bases"
    / "nvidia.com_dynamographdeploymentrequests.yaml"
)

_SCHEMA_FILE = _OPERATOR_DIR / "api" / "schemas" / "planner_config_json_schema.json"

# Keys emitted by Pydantic's JSON schema that are not valid in a Kubernetes
# structural schema.  Kubernetes only understands a subset of JSON Schema Draft
# 2020-12; these keys either cause validation failures or are simply ignored.
_STRIP_KEYS = frozenset({"title", "$schema"})


def _resolve_refs(schema: dict, defs: dict) -> dict:
    """Recursively inline ``$ref`` references from ``$defs``."""
    if "$ref" in schema:
        ref_path = schema["$ref"]
        if ref_path.startswith("#/$defs/"):
            def_name = ref_path[len("#/$defs/") :]
            if def_name in defs:
                resolved = _resolve_refs(copy.deepcopy(defs[def_name]), defs)
                # Merge sibling keys (e.g. description) on top of the resolved schema
                for k, v in schema.items():
                    if k != "$ref":
                        resolved[k] = v
                return resolved
        # Unknown $ref â€” leave as-is
        return schema

    result: dict = {}
    for key, value in schema.items():
        if key == "$defs":
            continue  # Drop after resolving; Kubernetes structural schemas don't use $defs
        if isinstance(value, dict):
            result[key] = _resolve_refs(value, defs)
        elif isinstance(value, list):
            result[key] = [
                _resolve_refs(item, defs) if isinstance(item, dict) else item
                for item in value
            ]
        else:
            result[key] = value
    return result


def _clean_for_k8s(schema: dict) -> dict:
    """Strip Pydantic-specific keys that Kubernetes does not understand."""
    result: dict = {}
    for key, value in schema.items():
        if key in _STRIP_KEYS:
            continue
        if isinstance(value, dict):
            result[key] = _clean_for_k8s(value)
        elif isinstance(value, list):
            result[key] = [
                _clean_for_k8s(item) if isinstance(item, dict) else item
                for item in value
            ]
        else:
            result[key] = value
    return result


def build_k8s_schema(schema_path: Path) -> dict:
    """Load, resolve, and clean the Pydantic JSON schema for CRD injection."""
    raw = json.loads(schema_path.read_text())
    defs = raw.get("$defs", {})
    resolved = _resolve_refs(raw, defs)
    return _clean_for_k8s(resolved)


def _extract_header(text: str) -> str:
    """Return the leading comment block (SPDX header) from a YAML file."""
    lines = []
    for line in text.splitlines():
        if line.startswith("#") or line == "":
            lines.append(line)
        else:
            break
    return "\n".join(lines) + ("\n" if lines else "")


def main() -> int:
    if not _SCHEMA_FILE.exists():
        print(f"Error: schema file not found: {_SCHEMA_FILE}", file=sys.stderr)
        print(
            "Run 'python -m dynamo.planner.utils.planner_config' first.",
            file=sys.stderr,
        )
        return 1

    if not _CRD_FILE.exists():
        print(f"Error: CRD file not found: {_CRD_FILE}", file=sys.stderr)
        print("Run 'make manifests' first.", file=sys.stderr)
        return 1

    k8s_schema = build_k8s_schema(_SCHEMA_FILE)

    crd_text = _CRD_FILE.read_text()
    crd = yaml.safe_load(crd_text)

    versions: list = crd.get("spec", {}).get("versions", [])
    injected = 0
    for version in versions:
        try:
            features_props: dict = version["schema"]["openAPIV3Schema"]["properties"][
                "spec"
            ]["properties"]["features"]["properties"]
        except (KeyError, TypeError):
            continue

        if "planner" not in features_props:
            continue

        # Preserve the operator-level description from the Go comment, then replace
        # the generic type:object/x-kubernetes-preserve-unknown-fields node with the
        # full PlannerConfig schema.  Keep x-kubernetes-preserve-unknown-fields for
        # forward compatibility so new PlannerConfig fields added after the CRD is
        # installed still pass validation.
        existing_description = features_props["planner"].get("description", "")
        new_planner = dict(k8s_schema)
        if existing_description:
            new_planner["description"] = existing_description
        new_planner["x-kubernetes-preserve-unknown-fields"] = True
        features_props["planner"] = new_planner
        injected += 1

    if injected == 0:
        print(
            "Warning: planner node not found in any CRD version schema.\n"
            "Have you run 'make manifests' after adding the planner field to FeaturesSpec?",
            file=sys.stderr,
        )
        return 1

    # Preserve the leading SPDX header comment, then write the modified YAML.
    header = _extract_header(crd_text)
    new_yaml = yaml.dump(
        crd,
        default_flow_style=False,
        allow_unicode=True,
        sort_keys=False,
        width=120,
    )
    _CRD_FILE.write_text(header + new_yaml)
    print(
        f"Injected PlannerConfig JSON schema into {injected} CRD version(s): {_CRD_FILE}"
    )
    return 0


if __name__ == "__main__":
    sys.exit(main())
