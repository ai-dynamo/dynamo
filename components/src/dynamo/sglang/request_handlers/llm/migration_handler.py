# SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

"""Handler for KV cache migration from decode workers.

This module provides functionality to migrate an in-flight request's KV cache
from one decode worker to another, reusing the prefill->decode KV transfer protocol.
"""

import logging
from typing import Any, AsyncGenerator, Dict

import sglang as sgl

from dynamo._core import Component, Context
from dynamo.sglang.args import Config
from dynamo.sglang.publisher import DynamoSglangPublisher
from dynamo.sglang.request_handlers.handler_base import BaseWorkerHandler


class MigrationHandler(BaseWorkerHandler):
    """Handler for KV cache migration on decode workers.

    This handler exposes a migrate endpoint that allows migrating an in-flight
    request's KV cache to another decode worker using the same protocol as
    prefill->decode transfer.
    """

    def __init__(
        self,
        component: Component,
        engine: sgl.Engine,
        config: Config,
        publisher: DynamoSglangPublisher,
    ) -> None:
        """Initialize migration handler.

        Args:
            component: The Dynamo runtime component.
            engine: The SGLang engine instance.
            config: SGLang and Dynamo configuration.
            publisher: The SGLang publisher instance.
        """
        self.engine = engine
        self.bootstrap_host, self.bootstrap_port = self._get_bootstrap_info(self.engine)
        super().__init__(component, engine, config, publisher)
        logging.info(
            f"Migration handler initialized - bootstrap host: {self.bootstrap_host}, "
            f"bootstrap port: {self.bootstrap_port}"
        )

    async def generate(self, request: Dict[str, Any], context: Context):
        """Not used for migration handler - use migrate() instead."""
        raise NotImplementedError(
            "MigrationHandler does not implement generate(). Use migrate() instead."
        )

    async def migrate(
        self, request: Dict[str, Any], context: Context
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """Initiate migration of an in-flight request's KV cache.

        This method:
        1. Generates bootstrap info (host, port, room)
        2. Triggers the KV transfer and waits for pending outputs
        3. Yields the response with bootstrap_info and pending_outputs

        The caller should pass the returned bootstrap_info to the destination
        decode worker, which will use it to receive the KV cache.

        Args:
            request: Request dict with:
                - 'rid': Request ID to migrate (required)
                - 'tokens_seen': Number of tokens already yielded to client (optional, default 0)
            context: Context object for request tracking.

        Yields:
            Dict with:
                - rid: Request ID
                - bootstrap_info: Connection details for KV transfer
                - pending_outputs: List of output chunks the frontend hasn't seen yet

        Raises:
            ValueError: If 'rid' is not provided in request.
        """
        rid = request.get("rid")
        if not rid:
            raise ValueError("'rid' is required in migration request")

        tokens_seen = request.get("tokens_seen", 0)

        logging.info(
            f"Processing migration request for rid: {rid}, tokens_seen: {tokens_seen}"
        )

        # Trigger the migration in the SGLang engine and get pending outputs
        # This will:
        # 1. Find and remove the request from running_batch
        # 2. Generate bootstrap_room with src_dp_rank encoded (room % dp_size == src_dp_rank)
        # 3. Setup KV sender with the bootstrap info
        # 4. Return the bootstrap_room along with pending outputs
        #
        # NOTE: The bootstrap_room is generated by the scheduler (not here) because
        # the scheduler knows its dp_rank. The room is encoded such that the destination's
        # KV receiver can derive the source DP rank via: bootstrap_room % dp_size.
        # This avoids needing to pass data_parallel_rank which would also affect routing.
        result = await self.engine.migrate_request(
            rid=rid,
            bootstrap_host=self.bootstrap_host,
            bootstrap_port=self.bootstrap_port,
            bootstrap_room=0,  # Ignored - scheduler generates the actual room
            tokens_seen=tokens_seen,
        )

        # Extract results from scheduler response
        pending_outputs = result.get("pending_outputs", [])
        src_dp_rank = result.get("src_dp_rank")
        bootstrap_room = result.get("bootstrap_room")

        bootstrap_info = {
            "bootstrap_host": self.bootstrap_host,
            "bootstrap_port": self.bootstrap_port,
            "bootstrap_room": bootstrap_room,
        }

        logging.debug(
            f"Migration bootstrap info for {rid}: "
            f"host={self.bootstrap_host}, port={self.bootstrap_port}, room={bootstrap_room}"
        )

        logging.info(
            f"Migration initiated for rid: {rid}, room: {bootstrap_room}, "
            f"pending_outputs: {len(pending_outputs)}, src_dp_rank: {src_dp_rank}"
        )

        yield {
            "rid": rid,
            "bootstrap_info": bootstrap_info,
            "pending_outputs": pending_outputs,
            "src_dp_rank": src_dp_rank,
        }
